---
description: Testing guidelines for stores, domain logic, and data layer
globs: ["**/*.test.ts", "**/*.spec.ts"]
---

# Testing Guidelines

## Test Framework

We use **Vitest** for unit testing.

```bash
npm test           # Run all tests once
npm run test:watch # Run tests in watch mode
```

## Test Directory Structure

```
src/
├── data/
│   ├── exercises/__tests__/
│   │   └── repository.test.ts
│   ├── recordings/__tests__/
│   │   └── repository.test.ts
│   └── exercise-session/__tests__/
│       └── repository.test.ts
├── __fixtures__/__tests__/
│   ├── sample-generator.test.ts
│   └── session-generator.test.ts
├── domain/
│   ├── voltra/protocol/__tests__/
│   │   └── telemetry-codec.test.ts
│   └── bluetooth/adapters/__tests__/
│       └── replay.test.ts
└── stores/__tests__/
```

## What to Test

| Target | Approach |
|--------|----------|
| Repositories | CRUD operations with InMemoryAdapter |
| Fixture generators | Output validity, validation through real logic |
| Domain logic | Use behavioral fixtures (aggregators, detectors, planners) |
| Stores | State transitions, business logic |
| Integration flows | Use session compositions for realistic scenarios |

## What NOT to Test

- **Screens** - they're just orchestration
- **Hooks** - they're thin bindings to stores
- **Component rendering logic** - test the stores instead

## Repository Testing Pattern (Critical)

**Always use `InMemoryAdapter` for repository tests** - this provides isolated, fast tests without AsyncStorage.

```typescript
// data/exercises/__tests__/repository.test.ts
import { describe, it, expect, beforeEach } from 'vitest';
import { InMemoryAdapter } from '@/data/adapters/in-memory-adapter';
import { createExerciseRepository } from '../repository';

describe('ExerciseRepository', () => {
  let adapter: InMemoryAdapter;
  let repo: ExerciseRepository;

  beforeEach(() => {
    adapter = new InMemoryAdapter();
    repo = createExerciseRepository(adapter);
  });

  it('saves and retrieves exercise', async () => {
    const exercise = createTestExercise({ id: 'test-1' });
    await repo.save(exercise);
    
    const retrieved = await repo.getById('test-1');
    expect(retrieved?.id).toBe('test-1');
  });

  it('returns null for non-existent', async () => {
    const retrieved = await repo.getById('does-not-exist');
    expect(retrieved).toBeNull();
  });
});
```

### Test Helper Pattern

Create test helpers to generate valid entities:

```typescript
function createTestExercise(overrides = {}): StoredExercise {
  return {
    id: `test-${Date.now()}`,
    name: 'Test Exercise',
    muscleGroups: ['back'],
    movementPattern: 'pull',
    isCustom: false,
    createdAt: Date.now(),
    updatedAt: Date.now(),
    ...overrides,
  };
}
```

## Behavioral Fixtures Infrastructure

We use **physics-based behavioral fixtures** that model realistic exercise data.
Prefer these over simple mocks for testing domain logic.

### Rep Behaviors

Generate samples for specific physical phenomena:

| Behavior | Velocity | Physics |
|----------|----------|---------|
| `explosive` | 0.9+ m/s | Quick concentric, smooth curve |
| `normal` | 0.6-0.8 m/s | Standard timing, controlled |
| `fatiguing` | 0.4-0.6 m/s | Slower, eccentric speeds up |
| `grinding` | 0.2-0.4 m/s | Long concentric, sticking point |
| `failed` | → 0 m/s | Stalls mid-concentric, no eccentric |
| `partial` | ~0.6 m/s | Reduced ROM (<80%) |

```typescript
import { generateRepSamples } from '@/__fixtures__/generators';

const samples = generateRepSamples('grinding', { weight: 100 });
```

### Set Compositions

Combine rep behaviors into realistic sets:

```typescript
import { generateSetFromBehaviors, setPresets, sets } from '@/__fixtures__/generators';

// Use a preset
const { samples, set } = generateSetFromBehaviors(setPresets.toFailure, {
  weight: 100,
  processWithAggregators: true,
});

// Or define custom composition
const customSet = generateSetFromBehaviors(
  ['normal', 'normal', 'fatiguing', 'grinding', 'failed'],
  { weight: 100 }
);

// Convenience function
const { set } = sets.productiveWorking(100, { processWithAggregators: true });
```

### Session Compositions

Build full sessions with warmups and working sets:

```typescript
import { generateSessionFromComposition, sessionPresets, sessions } from '@/__fixtures__/generators';

// Generate from preset
const { session, plan, totalReps, totalVolume } = generateSessionFromComposition(
  sessionPresets.standardWorkout,
  { workingWeight: 100, goal: TrainingGoal.HYPERTROPHY }
);

// Convenience function
const { session } = sessions.standard(100);
```

### Planning Fixtures

Generate planning contexts for testing planners:

```typescript
import {
  generatePlanningContext,
  generateHistoricalMetrics,
  generateSessionMetrics,
} from '@/__fixtures__/generators';

const context = generatePlanningContext({
  goal: TrainingGoal.STRENGTH,
  historicalMetrics: { lastWorkingWeight: 100, sessionCount: 10 },
  sessionMetrics: { fatigueLevel: 0.5 },
});
```

## Real Data vs Mocks

### When to Use Behavioral Fixtures (Preferred)

- Testing domain logic (aggregators, detectors, planners)
- Testing data flow through multiple components
- Integration tests
- UI demonstrations and storybook

```typescript
// GOOD: Real data through real logic
it('detects velocity grinding termination', () => {
  const { set } = generateSetFromBehaviors(setPresets.junkVolume, {
    weight: 100,
    processWithAggregators: true,
  });
  
  const result = checkTermination(session, set);
  expect(result.reason).toBe('velocity_grinding');
});
```

### When to Use Mocks

- External dependencies (BLE, AsyncStorage, network)
- Time-dependent logic (use fake timers instead of mocks when possible)
- Error path testing where you need to force specific failures

```typescript
// OK: Mock external dependency
vi.mock('react-native-ble-plx', () => ({
  BleManager: vi.fn(),
}));
```

## Fixture Validation

Behavioral fixtures are validated by running through real domain logic.
This ensures they produce realistic, correct data.

### Validation Tests Check:

1. **Rep behaviors** pass through `RepDetector` correctly
2. **Failed reps** are NOT detected as complete (correct behavior)
3. **Set presets** produce expected velocity loss ranges
4. **Session presets** produce expected metrics

```typescript
// This is how we validate fixtures - by running them through real logic
it('toFailure preset shows >30% velocity loss', () => {
  const { set } = generateSetFromBehaviors(setPresets.toFailure, {
    weight: 100,
    processWithAggregators: true,
  });
  
  const velocityLoss = 
    (set.reps[0].metrics.concentricMeanVelocity - 
     set.reps[set.reps.length - 1].metrics.concentricMeanVelocity) /
    set.reps[0].metrics.concentricMeanVelocity;
    
  expect(velocityLoss).toBeGreaterThan(0.3);
});
```

## Fixture Generator Testing

Test that generators produce valid data:

```typescript
// __fixtures__/__tests__/sample-generator.test.ts
describe('generateSampleStream()', () => {
  beforeEach(() => {
    resetSequence(); // Reset sequence counter between tests
  });

  it('generates samples with all movement phases', () => {
    const samples = generateSampleStream({ repCount: 2 });
    const phases = new Set(samples.map(s => s.phase));

    expect(phases.has(MovementPhase.IDLE)).toBe(true);
    expect(phases.has(MovementPhase.CONCENTRIC)).toBe(true);
    expect(phases.has(MovementPhase.HOLD)).toBe(true);
    expect(phases.has(MovementPhase.ECCENTRIC)).toBe(true);
  });

  it('sequences are continuous', () => {
    const samples = generateSampleStream({ repCount: 2 });
    for (let i = 0; i < samples.length; i++) {
      expect(samples[i].sequence).toBe(i);
    }
  });
});
```

## Protocol Roundtrip Testing

For telemetry encoding, test encode → decode preserves all fields:

```typescript
// domain/voltra/protocol/__tests__/telemetry-codec.test.ts
describe('encode → decode roundtrip', () => {
  it('preserves all frame fields', () => {
    const original = createFrame(9999, MovementPhase.CONCENTRIC, 450, -75, 250);
    
    const encoded = encodeTelemetryFrame(original);
    const decoded = decodeTelemetryFrame(encoded);

    expect(decoded!.sequence).toBe(9999);
    expect(decoded!.phase).toBe(MovementPhase.CONCENTRIC);
    expect(decoded!.position).toBe(450);
    expect(decoded!.force).toBe(-75);  // Test negative values!
    expect(decoded!.velocity).toBe(250);
  });
});
```

## Adapter Testing with Fake Timers

For time-based logic (like ReplayBLEAdapter), use Vitest fake timers:

```typescript
import { vi, beforeEach, afterEach } from 'vitest';

describe('ReplayBLEAdapter', () => {
  beforeEach(() => {
    vi.useFakeTimers();
  });

  afterEach(() => {
    vi.useRealTimers();
  });

  it('connect() transitions to connected', async () => {
    const connectPromise = adapter.connect('replay-device');
    await vi.runAllTimersAsync();
    await connectPromise;

    expect(adapter.isConnected()).toBe(true);
  });

  it('playback emits samples at intervals', () => {
    const callback = vi.fn();
    adapter.onNotification(callback);

    adapter.play();
    expect(callback).toHaveBeenCalledTimes(1);

    vi.advanceTimersByTime(500);
    expect(callback.mock.calls.length).toBeGreaterThan(1);
  });
});
```

## Store Testing Pattern

```typescript
// stores/__tests__/connection-store.test.ts
describe('connection-store', () => {
  beforeEach(() => {
    useConnectionStore.setState(initialState);
  });

  it('should update relay status on successful check', async () => {
    const store = useConnectionStore.getState();
    await store.checkRelayStatus();
    expect(store.relayStatus).toBe('connected');
  });
});
```

## Key Principles

- **Use InMemoryAdapter** for all repository tests (isolation, speed)
- **Prefer behavioral fixtures over mocks** for domain logic testing
- **Use fixture generators** instead of hardcoded test data
- **Validate fixtures through real domain logic** (RepDetector, aggregators)
- **Reset state in beforeEach** - generators, adapters, stores
- **Test edge cases** - empty data, max values, negative numbers
- **Use fake timers** for time-dependent logic
- Focus on behavior, not implementation details
