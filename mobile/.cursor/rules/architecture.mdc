---
description: Core architecture layers and directory structure for the Voltra mobile app
alwaysApply: true
---

# Architecture Layers

```
app/(tabs)/        → Route files (re-export screens)
components/        → All UI (screens, domain, primitives)
hooks/             → React bindings to stores (NO hooks in components/)
stores/            → Thin reactive wrappers over domain controllers (Zustand)
domain/            → Business logic, models, controllers, analytics, training
data/              → Persistence, repositories, storage adapters
__fixtures__/      → Test data generators, seeders
```

## Directory Structure

```
domain/
├── bluetooth/     # BLE connection, scanning, environment, adapters
│   ├── adapters/  # BLEAdapter implementations (native, proxy)
│   ├── models/
│   └── controllers/
├── exercise/      # Pure exercise definitions (metadata only)
│   ├── types.ts   # Exercise interface, MuscleGroup enum
│   ├── catalog.ts # EXERCISE_CATALOG, getExercise, getAllExercises
│   └── mappings.ts # EXERCISE_MUSCLE_GROUPS, getExerciseName
├── history/       # Computed data from set history (velocity baselines, PRs, trends)
│   ├── models/    # VelocityBaseline, PersonalRecord, TrendAnalysis
│   └── services/  # computeVelocityBaseline, computePersonalRecords
├── planning/      # Unified planning system (replaces training/)
│   ├── types.ts   # TrainingGoal enum, PlanningContext, PlanResult
│   ├── planner.ts # planExercise() - unified entry point
│   └── strategies/ # standard.ts, discovery.ts, progression.ts
├── vbt/           # VBT constants, load-velocity profiles, 1RM estimation
│   ├── constants.ts # VELOCITY_AT_PERCENT_1RM, TRAINING_ZONES
│   └── profile.ts  # buildLoadVelocityProfile, generateWorkingWeightRecommendation
├── voltra/        # Voltra device, telemetry, protocol
│   ├── models/
│   ├── controllers/
│   ├── adapters/  # SampleAdapter (TelemetryFrame → WorkoutSample)
│   └── protocol/
├── workout/       # Hardware-agnostic workout models and analytics
│   ├── models/    # Rep, Set, SetMetrics, WorkoutSample, ExerciseSession, ExercisePlan
│   ├── detectors/ # RepDetector
│   ├── aggregators/
│   ├── metrics/   # SessionMetrics, baseline, strength/fatigue/readiness estimates
│   ├── planners/  # standard-planner, discovery-planner
│   └── session/   # Termination logic
└── shared/        # Utilities, shared types

data/
├── provider.ts        # Centralized repository access (singleton pattern)
├── exercise-session/  # Exercise sessions (unified storage)
│   ├── exercise-session-schema.ts      # StoredExerciseSession
│   ├── exercise-session-repository.ts  # ExerciseSessionRepository
│   ├── exercise-session-converters.ts  # Domain ↔ Storage
│   └── index.ts
├── exercises/         # Exercise definitions (persisted catalog)
│   ├── exercise-schema.ts      # StoredExercise
│   ├── exercise-repository.ts  # ExerciseRepository
│   ├── exercise-bootstrap.ts   # Seed catalog from domain
│   └── index.ts
├── recordings/        # Sample recordings (debug telemetry)
│   ├── recording-schema.ts      # SampleRecording
│   ├── recording-repository.ts  # RecordingRepository
│   └── index.ts
├── preferences/       # Device and connection preferences
│   ├── preferences-schema.ts
│   ├── preferences-storage.ts
│   └── index.ts
└── adapters/          # Storage abstraction layer
    ├── types.ts                  # StorageAdapter interface, STORAGE_KEYS
    ├── async-storage-adapter.ts  # Production (AsyncStorage)
    └── in-memory-adapter.ts      # Testing (isolated)

components/
├── ui/            # App-agnostic primitives (Card, Button, Banner, etc.)
│   ├── layout/    # Card, Surface, Stack, Divider, Section
│   ├── feedback/  # Banner, EmptyState, LoadingState, ErrorBanner
│   ├── inputs/    # ActionButton, OptionSelector
│   ├── display/   # StatDisplay, StatsRow, Badge, IconBox, ListItem
│   ├── navigation/# LinkCard
│   └── overlays/  # BottomSheet
├── device/        # Voltra connection, BLE, scanning
├── recording/     # Intra-set recording (RecordingDisplay, LiveMetrics)
├── exercise/      # Exercise session UI (SetTargetCard, SessionProgress)
├── analytics/     # Charts, history, summaries
├── planning/      # Exercise selection, goals, weight setup
└── screens/       # Flat files: ExerciseScreen.tsx, ExercisePickerScreen.tsx, etc.
```

## Responsibility Separation

| Layer | Responsibility | Examples |
|-------|---------------|----------|
| `domain/` | Business logic, models, controllers | VoltraDevice, TelemetryController, RepDetector |
| `domain/history/` | Computed data from set history | computeVelocityBaseline, computePersonalRecords |
| `stores/` | Thin reactive wrappers, state sync | voltra-store, recording-store, connection-store |
| `hooks/` | Cross-store orchestration | useDiscoveryFlow |
| `components/` | UI rendering only | All .tsx files |
| `data/` | Entity-based persistence | ExerciseSessionRepository, RecordingRepository |
| `__fixtures__/` | Test data generation, database seeding | generateSampleStream, seedDatabase |

## Domain-First Design

Business logic lives in `domain/` modules, not stores:

1. **Models** define state and validation (no async, no React)
2. **Controllers** coordinate models with external systems (BLE, timers)
3. **Services** compute derived data (velocity baselines, personal records)
4. **Stores** expose domain state to React with granular updates
5. **Components** render UI from store state

## Data Layer Patterns

### Entity-Based Organization

Data is organized by entity, not by type. Files use explicit entity-prefixed names:

```
# GOOD: Entity-based with explicit file names
data/exercise-session/
├── exercise-session-schema.ts      # Types (StoredExerciseSession, etc.)
├── exercise-session-converters.ts  # Domain ↔ Storage conversion
├── exercise-session-repository.ts  # CRUD operations
└── index.ts

# BAD: Type-based (old pattern)
data/models/     # All types mixed
data/repositories/ # All repos mixed
```

### Schema Files

Schema files define the storage format only (no functions):

```typescript
// data/exercise-session/exercise-session-schema.ts - Types only
export interface StoredExerciseSession { ... }
export interface StoredSessionSet { ... }
```

### Converters

Converters transform between domain models and storage schemas:

```typescript
// data/exercise-session/converters.ts
export function toStoredSession(session: ExerciseSession): StoredExerciseSession { ... }
export function fromStoredSession(stored: StoredExerciseSession): ExerciseSession { ... }
```

### Repositories

Repositories are CRUD-only. No business logic:

```typescript
// GOOD: Pure data access
interface ExerciseSessionRepository {
  getById(id: string): Promise<StoredExerciseSession | null>;
  getRecent(limit: number): Promise<StoredExerciseSession[]>;
  save(session: StoredExerciseSession): Promise<void>;
  delete(id: string): Promise<void>;
  getByExercise(exerciseId: string): Promise<StoredExerciseSession[]>;
}

// BAD: Business logic in repository
getAggregateStats(): Promise<Stats>;  // Move to domain/history
getTopPerformers(): Promise<Session[]>;   // Move to domain/history
```

### Simplified Storage

For simple entities, use storage functions instead of full repositories:

```typescript
// data/preferences/preferences-storage.ts
export async function getLastDevice(): Promise<Device | null>;
export async function saveLastDevice(device: Device): Promise<void>;
export async function clearLastDevice(): Promise<void>;
```

### Computed Data

Computed/derived types belong in domain, not data:

```typescript
// domain/history/models/
VelocityBaseline  // Computed from stored sets
PersonalRecord    // Computed from stored sets

// domain/history/services/
computeVelocityBaseline(sets) → VelocityBaseline
computePersonalRecords(sets) → PersonalRecord[]
```

### Centralized Repository Access

**Always use `data/provider.ts` to access repositories** - never instantiate repositories directly in components or stores.

```typescript
// GOOD: Use centralized provider
import { getSessionRepository, getExerciseRepository } from '@/data/provider';

const session = await getSessionRepository().getById(id);
const exercises = await getExerciseRepository().getAll();

// BAD: Direct instantiation
const repo = createExerciseSessionRepository(adapter); // Don't do this in UI code
```

The provider manages singleton instances and storage adapter initialization:

```typescript
// data/provider.ts exports:
getAdapter()              // StorageAdapter (AsyncStorage in prod)
getSessionRepository()    // ExerciseSessionRepository
getExerciseRepository()   // ExerciseRepository
getRecordingRepository()  // RecordingRepository
isDebugTelemetryEnabled() // Check debug mode
setDebugTelemetryEnabled(enabled) // Toggle debug mode
```

### Storage Adapter Interface

All repositories use the `StorageAdapter` interface for storage operations:

```typescript
interface StorageAdapter {
  getItem(key: string): Promise<string | null>;
  setItem(key: string, value: string): Promise<void>;
  removeItem(key: string): Promise<void>;
  getAllKeys(): Promise<string[]>;
  multiGet(keys: string[]): Promise<[string, string | null][]>;
}
```

Two implementations:
- `AsyncStorageAdapter` - Production (wraps @react-native-async-storage)
- `InMemoryAdapter` - Testing (isolated, fast, no side effects)

## Fixtures & Data Generation

Test fixtures live in `src/__fixtures__/`:

```
__fixtures__/
├── generators/
│   ├── sample-generator.ts   # WorkoutSample, sample streams
│   ├── session-generator.ts  # StoredSet, StoredExerciseSession
│   ├── recording-generator.ts # SampleRecording
│   └── index.ts
├── seeder.ts                 # seedDatabase(), clearSeedData()
└── index.ts
```

### Generator Functions

Generators create realistic test data with configurable options:

```typescript
// Generate a single WorkoutSample
const sample = generateWorkoutSample({ phase: MovementPhase.CONCENTRIC });

// Generate a stream of samples for N reps
const samples = generateSampleStream({
  repCount: 8,
  startingVelocity: 1.0,
  fatigueRate: 0.05,
});

// Generate a complete session
const session = generateStoredSession({
  exerciseId: 'bench_press',
  setCount: 4,
  daysAgo: 3,
  includeRawSamples: true, // Include debug telemetry
});

// Generate a sample recording
const recording = generateRecording({
  repCount: 8,
  weight: 150,
});
```

### Database Seeding

For development and testing:

```typescript
import { seedDatabase, clearSeedData } from '@/__fixtures__';

// Seed with default options
await seedDatabase();

// Seed with specific options
await seedDatabase({
  sessionsCount: 20,
  daysBack: 30,
  includeRawSamples: true,
  includeRecordings: true,
});

// Clear all seeded data
await clearSeedData();
```

### Debug Telemetry

When debug telemetry is enabled, raw `WorkoutSample[]` are stored with sets and as standalone recordings. This enables:

- Replay-based development (visualizations, tools)
- Data analysis without physical device
- Testing the full telemetry pipeline

Toggle via: `setDebugTelemetryEnabled(true)` or Dev Tools in Settings.
